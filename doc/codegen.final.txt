>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=

                         888888 888888    db    8b    d8
                           88   88__     dPYb   88b  d88
                           88   88""    dP__Yb  88YbdP88
                           88   888888 dP""""Yb 88 YY 88

 88   88 88b 88 888888 Yb    dP    db    88     88   88    db    888888 888888 8888b.
 88   88 88Yb88 88__    Yb  dP    dPYb   88     88   88   dPYb     88   88__    8I  Yb 
 Y8   8P 88 Y88 88""     YbdP    dP__Yb  88  .o Y8   8P  dP__Yb    88   88""    8I  dY 
 `YbodP' 88  Y8 888888    YP    dP""""Yb 88ood8 `YbodP' dP""""Yb   88   888888 8888Y"

>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=>>=

                               presents a code generator


			   Data Manipulation

Manipulating the necessary data structures for code generation and
data flow analysis presents several problems in Haskell.  

     	  	   	   Generic Programming

The type system is fantastic for checking errors (giving us the data
structure integrity checkers mentioned in class automatically) but it
introduces a lot of boilerplate code when we need to iterate over our
recursive type structures.  The register allocator, for instance,
needs to search the LIRProgram tree, which involves roughly 15 data
types (representing instructions), for just symbolic registers and
update their labels.  This would traditionally require 15 function
declarations, as would any other later iteration function we discover
we need, and they would all depend on the exact structure of the data
type.  Adding one member would require us to change the function
definitions for each iteration function.  

Luckily, Haskell includes a basic dynamic typing function which solves
our problem and also avoids breaking the static type system.
Data.Data includes a type-safe cast function:

	  (cast 5) :: Integer = Just 5
	  (cast 'a') :: Integer = Nothing

Which is straightforward to use.  This allows us to define a "make generic" function
      
      (a is some given type)
      f :: a -> m a

      mkM f = case cast f of 
      	      Just g -> g
              Nothing -> return

defined for monadic functions.  Now, (mkM f) can be applied to *any*
type implementing the class Typeable, which allows for run-time type
checks.  If it is applied to x :: a, then we get back f a; otherwise,
if x does not have type a, we get back x.

Now, for any recursive data type we have, we implement an interface function


    gmapM f (Thing arg1 arg2 arg3 ) = do a1 <- f arg1
    	    	   	     	         a2 <- f arg2
    	    	   	     	         a3 <- f arg3
                                         return $ Thing a1 a2 a3

this gives us a way to apply polymorphic functions (like mkM f) to Thing's.  Defining gmapM for the types and subtypes of arg1, arg2, arge3, etc, we can get a full traversal using everywhere:

     everywhereM f x = do x' <- gmapM (everywhereM f) x
                          f x'

this one is responsible for recursively applying f to all
subexpressions of x.  It changes those things which it is defined on,
and leaves everything else alone.


We use this to naively assign registers.  All that's necessary,
after the above interface is defined, is to create a function ::
LIRReg -> RegAllocator LIRReg which looks up how many variables have
been used in the current stack frame (using the monad), and then
annotates the reg with the current number.  This transforms an
LIRProgram into a new one, where SREG's have been assigned stack
offsets.  It also returns the total number of variables defined in the
global scope and each function scope, so that we can output enter op
codes, and it does so in only about 30 lines of code.




       	      	      	 Graphs

We implemented a basic control flow graph.  Our original plan was to
implement a generic graph type, since graph algorithms will be
important for future intelligent register allocation and data flow
algorithms.  However, we found that working with graphs (and other
non-recursive data types) is very awkward in Haskell.  There is
extensive literature on this subject, but still no conclusive
solutions.

The control flow graph is implemented recursively:


data ControlNode = BasicBlock [LIRInst]
                 | Branch
                   { condReg :: LIROperand
                   , branchNumber :: Int
                   , trueBlock  :: ControlPath
                   , falseBlock :: ControlPath
                   }

type ControlPath = [ControlNode]

Branches simply recombine at the next node.  Back edges are traversed
by just moving up in the ControlNode list.  Loops are as of yet not
specially marked.

I believe that using the generic programming techniques outlined in
the previous section may allow us to construct zippers for any type
implementing Data.  This would give us a rich set of operations for
manipulating ControlFlow graphs.  It would also help us implement
graph algorithms while ignoring the exact representation of the
graphs.


			ControlFlowGraph

The output of the translate functions in Translator.hs is a slightly
abstracted version of LIR.  It preserves the structures of if's and
expressions involving && and ||.  Everything else is flattened to LIR.
This output is taken by the CFG constructor: it creates a graph and
generates short-circuit evaluation code for all expressions.  This
representation can then be converted into straight LIR code, which is
easily converted to assembly.
