  TestLabel "char1" (parser "
// Mundane characters.
'a' 'b' 'c'
'R' 'i' 'n' 'a' 'r' 'd'
'6' '0' '3' '5'
"
                                           ~=?
"[L2:C1-4] CHARLITERAL 'a'\n[L2:C5-8] CHARLITERAL 'b'\n[L2:C9-12] CHARLITERAL 'c'\n[L3:C1-4] CHARLITERAL 'R'\n[L3:C5-8] CHARLITERAL 'i'\n[L3:C9-12] CHARLITERAL 'n'\n[L3:C13-16] CHARLITERAL 'a'\n[L3:C17-20] CHARLITERAL 'r'\n[L3:C21-24] CHARLITERAL 'd'\n[L4:C1-4] CHARLITERAL '6'\n[L4:C5-8] CHARLITERAL '0'\n[L4:C9-12] CHARLITERAL '3'\n[L4:C13-16] CHARLITERAL '5'\n"
                                            ),



  TestLabel "char2" (parser "
// Backslashed characters.
'\n' '\t' '\\' '\"'
"
                                           ~=?
"[L2:C1-5] CHARLITERAL '\\n'\n[L2:C6-10] CHARLITERAL '\\t'\n[L2:C11-15] CHARLITERAL '\\\\'\n[L2:C16-20] CHARLITERAL '\\\"'\n"
                                            ),



  TestLabel "char3" (parser "
// Mismatched single quotes.
'''
"
                                           ~=?
Decaf Compiler
File // Mismatched single quotes.
'''
 has lex errors!
Token Stream:


[L2:C2-4] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 2):
unexpected "'"
expecting quoted character
[L2:C4-6] SCANNER ERROR: "decaf-scanner-eatNext" (line 2, column 4):
unexpected "\n"
expecting quoted character

                                            ),



  TestLabel "char4" (parser "
// Invalid backslashed character.
'\p'
"
                                           ~=?
Decaf Compiler
File // Invalid backslashed character.
'\p'
 has lex errors!
Token Stream:


[L2:C3-5] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 3):
unexpected "p"
expecting "'"
[L2:C5-7] SCANNER ERROR: "decaf-scanner-eatNext" (line 2, column 5):
unexpected "\n"
expecting quoted character

                                            ),



  TestLabel "char5" (parser "
// newline isn't a valid char.
'
'
"
                                           ~=?
Decaf Compiler
File // newline isn't a valid char.
'
'
 has lex errors!
Token Stream:


[L2:C2-4] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 2):
unexpected "\n"
expecting quoted character
[L3:C2-4] SCANNER ERROR: "decaf-scanner-eatNext" (line 3, column 2):
unexpected "\n"
expecting quoted character

                                            ),



  TestLabel "char6" (parser "
// Double quotes need to be escaped.
'"'
"
                                           ~=?
Decaf Compiler
File // Double quotes need to be escaped.
'"'
 has lex errors!
Token Stream:


[L2:C2-4] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 2):
unexpected "\""
expecting quoted character
[L2:C4-6] SCANNER ERROR: "decaf-scanner-eatNext" (line 2, column 4):
unexpected "\n"
expecting quoted character

                                            ),



  TestLabel "char7" (parser "
// The backslash quotes the single quote, and the char literal doesn't end.
'\'
"
                                           ~=?
Decaf Compiler
File // The backslash quotes the single quote, and the char literal doesn't end.
'\'
 has lex errors!
Token Stream:


[L2:C4-6] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 4):
unexpected "\n"
expecting "'"

                                            ),



  TestLabel "char8" (parser "
// Char literals can only have one char.
'ab'
"
                                           ~=?
Decaf Compiler
File // Char literals can only have one char.
'ab'
 has lex errors!
Token Stream:


[L2:C3-5] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 3):
unexpected "b"
expecting "'"
[L2:C5-7] SCANNER ERROR: "decaf-scanner-eatNext" (line 2, column 5):
unexpected "\n"
expecting quoted character

                                            ),



  TestLabel "char9" (parser "
// Tab inside a quoted string.
'	'
"
                                           ~=?
"[L2:C1-4] CHARLITERAL ' '\n"
                                            ),



  TestLabel "hexlit1" (parser "
// Basic hexadecimal literals.
0x0
0x1
0xe43620
0x11
0xbeef
0xF
0xF00
0xB1ad
"
                                           ~=?
"[L2:C1-4] INTLITERAL 0x0\n[L3:C1-4] INTLITERAL 0x1\n[L4:C1-9] INTLITERAL 0xe43620\n[L5:C1-5] INTLITERAL 0x11\n[L6:C1-7] INTLITERAL 0xbeef\n[L7:C1-4] INTLITERAL 0xF\n[L8:C1-6] INTLITERAL 0xF00\n[L9:C1-7] INTLITERAL 0xB1ad\n"
                                            ),



  TestLabel "hexlit2" (parser "
// This is way too big, but we're not checking this in the scanner.
0xDEADBEEF
"
                                           ~=?
"[L2:C1-11] INTLITERAL 0xDEADBEEF\n"
                                            ),



  TestLabel "hexlit3" (parser "
// This isn't a hex literal, since there are no digits.
0x
"
                                           ~=?
Decaf Compiler
File // This isn't a hex literal, since there are no digits.
0x
 has lex errors!
Token Stream:


[L2:C3-5] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 3):
unexpected "\n"
expecting hexadecimal digit

                                            ),



  TestLabel "id1" (parser "
// Some valid identifiers of various sorts.
abcdefg
Rinard
martin_rinard
six_dot_035
_foo_

"
                                           ~=?
"[L2:C1-8] IDENTIFIER abcdefg\n[L3:C1-7] IDENTIFIER Rinard\n[L4:C1-14] IDENTIFIER martin_rinard\n[L5:C1-12] IDENTIFIER six_dot_035\n[L6:C1-6] IDENTIFIER _foo_\n"
                                            ),



  TestLabel "id2" (parser "
// This should not be a single identifier
foo.bar

"
                                           ~=?
Decaf Compiler
File // This should not be a single identifier
foo.bar

 has lex errors!
Token Stream:


[L2:C1-4] IDENTIFIER foo
[L2:C4-6] SCANNER ERROR: "decaf-scanner-eatNext" (line 2, column 4):
unexpected "."
expecting whitespace, operator, literal, identifier, ";", "[", "]", "(", ")", "{", "}", "," or end of input
[L2:C5-8] IDENTIFIER bar

                                            ),



  TestLabel "id3" (parser "
// Things with different cases
if
iF
If
foo Foo
New

"
                                           ~=?
"[L2:C1-3] if\n[L3:C1-3] IDENTIFIER iF\n[L4:C1-3] IDENTIFIER If\n[L5:C1-4] IDENTIFIER foo\n[L5:C5-8] IDENTIFIER Foo\n[L6:C1-4] IDENTIFIER New\n"
                                            ),



  TestLabel "number1" (parser "
// This number is too large, but we don't check in the scanner.  
-2147483649
"
                                           ~=?
"[L2:C1-2] -\n[L2:C2-12] INTLITERAL 2147483649\n"
                                            ),



  TestLabel "number2" (parser "
// Some perfectly normal mundane numbers.
0
1
-1
259
17
43 -620
"
                                           ~=?
"[L2:C1-2] INTLITERAL 0\n[L3:C1-2] INTLITERAL 1\n[L4:C1-2] -\n[L4:C2-3] INTLITERAL 1\n[L5:C1-4] INTLITERAL 259\n[L6:C1-3] INTLITERAL 17\n[L7:C1-3] INTLITERAL 43\n[L7:C4-5] -\n[L7:C5-8] INTLITERAL 620\n"
                                            ),



  TestLabel "op1" (parser "
// Some operators.
+ - * < <= != &&
"
                                           ~=?
"[L2:C1-2] +\n[L2:C3-4] -\n[L2:C5-6] *\n[L2:C7-8] <\n[L2:C9-11] <=\n[L2:C12-14] !=\n[L2:C15-17] &&\n"
                                            ),



  TestLabel "op2" (parser "
// ++ is two tokens, so these two lines are equivalent
a++
a+ +"
                                           ~=?
"[L2:C1-2] IDENTIFIER a\n[L2:C2-3] +\n[L2:C3-4] +\n[L3:C1-2] IDENTIFIER a\n[L3:C2-3] +\n[L3:C4-5] +\n"
                                            ),



  TestLabel "string1" (parser "
// Simple strings.  
"A string walks into a bar and orders a beer."
"The bartender looks at him and says, \"we don\'t serve strings here.\""
"The string walks out to the street, and sits on the curb, dejected."
"Then he has an idea: he ties himself into a bow, and loosens up his"
"ends, making them up into nice tassels."
"His confidence restored, he walks back into the bar, sits down, and orders"
"another beer."
"The bartender looks at him suspiciously: he looks a bit like the string"
"that had just walked in.  \"Hey,\" he says, \"aren\'t you a string?\""
"\"Nope,\" says the string.  \"I\'m a frayed knot.\""
"
                                           ~=?
"[L2:C1-47] STRINGLITERAL \"A string walks into a bar and orders a beer.\"\n[L3:C1-73] STRINGLITERAL \"The bartender looks at him and says, \\\"we don\\'t serve strings here.\\\"\"\n[L4:C1-70] STRINGLITERAL \"The string walks out to the street, and sits on the curb, dejected.\"\n[L5:C1-70] STRINGLITERAL \"Then he has an idea: he ties himself into a bow, and loosens up his\"\n[L6:C1-42] STRINGLITERAL \"ends, making them up into nice tassels.\"\n[L7:C1-77] STRINGLITERAL \"His confidence restored, he walks back into the bar, sits down, and orders\"\n[L8:C1-16] STRINGLITERAL \"another beer.\"\n[L9:C1-74] STRINGLITERAL \"The bartender looks at him suspiciously: he looks a bit like the string\"\n[L10:C1-72] STRINGLITERAL \"that had just walked in.  \\\"Hey,\\\" he says, \\\"aren\\'t you a string?\\\"\"\n[L11:C1-54] STRINGLITERAL \"\\\"Nope,\\\" says the string.  \\\"I\\'m a frayed knot.\\\"\"\n"
                                            ),



  TestLabel "string2" (parser "
// An unquoted single quote.
"Aren't you a string?"
"
                                           ~=?
Decaf Compiler
File // An unquoted single quote.
"Aren't you a string?"
 has lex errors!
Token Stream:


[L2:C6-8] SCANNER ERROR: "decaf-scanner-eatFirst" (line 2, column 6):
unexpected "'"
expecting quoted character or "\""
[L2:C7-8] IDENTIFIER t
[L2:C9-12] IDENTIFIER you
[L2:C13-14] IDENTIFIER a
[L2:C15-21] IDENTIFIER string
[L2:C21-23] SCANNER ERROR: "decaf-scanner-eatNext" (line 2, column 21):
unexpected "?"
expecting whitespace, operator, literal, identifier, ";", "[", "]", "(", ")", "{", "}", "," or end of input
[L2:C23-25] SCANNER ERROR: "decaf-scanner-eatNext" (line 2, column 23):
unexpected "\n"
expecting quoted character or "\""

                                            ),



  TestLabel "string3" (parser "
// A string with a comment at the end
"I\" \\\"\'\'\t\tam a STRING\n"//comment
"
                                           ~=?
"[L2:C1-32] STRINGLITERAL \"I\\\" \\\\\\\"\\'\\'\\t\\tam a STRING\\n\"\n"
                                            ),



  TestLabel "tokens1" (parser "
// Decaf keywords
boolean
callout
class
else
false
if
int
return
true
void
for
forpar
break
continue
"
                                           ~=?
"[L2:C1-8] boolean\n[L3:C1-8] callout\n[L4:C1-6] class\n[L5:C1-5] else\n[L6:C1-6] BOOLEANLITERAL false\n[L7:C1-3] if\n[L8:C1-4] int\n[L9:C1-7] return\n[L10:C1-5] BOOLEANLITERAL true\n[L11:C1-5] void\n[L12:C1-4] for\n[L13:C1-7] IDENTIFIER forpar\n[L14:C1-6] break\n[L15:C1-9] continue\n"
                                            ),



  TestLabel "tokens2" (parser "
// Decaf keywords in uppercase.  This should be identifiers.
BOOLEAN
CALLOUT
CLASS
ELSE
FALSE
IF
INT
RETURN
TRUE
VOID
FOR
FORPAR
BREAK
CONTINUE
"
                                           ~=?
"[L2:C1-8] IDENTIFIER BOOLEAN\n[L3:C1-8] IDENTIFIER CALLOUT\n[L4:C1-6] IDENTIFIER CLASS\n[L5:C1-5] IDENTIFIER ELSE\n[L6:C1-6] IDENTIFIER FALSE\n[L7:C1-3] IDENTIFIER IF\n[L8:C1-4] IDENTIFIER INT\n[L9:C1-7] IDENTIFIER RETURN\n[L10:C1-5] IDENTIFIER TRUE\n[L11:C1-5] IDENTIFIER VOID\n[L12:C1-4] IDENTIFIER FOR\n[L13:C1-7] IDENTIFIER FORPAR\n[L14:C1-6] IDENTIFIER BREAK\n[L15:C1-9] IDENTIFIER CONTINUE\n"
                                            ),



  TestLabel "tokens3" (parser "
// Decaf keywords stuck together.  This should be one big identifier.
booleancalloutclasselsefalseifintreturntruevoidforforparbreakcontinue

"
                                           ~=?
"[L2:C1-70] IDENTIFIER booleancalloutclasselsefalseifintreturntruevoidforforparbreakcontinue\n"
                                            ),



  TestLabel "tokens4" (parser "
// Random tokens
{-123-a35,id3a,+*;}[||===!=()&&]<><=>==
a[24]='7'; n!=if;
false,-if;true32;
forpar

"
                                           ~=?
"[L2:C1-2] {\n[L2:C2-3] -\n[L2:C3-6] INTLITERAL 123\n[L2:C6-7] -\n[L2:C7-10] IDENTIFIER a35\n[L2:C10-11] ,\n[L2:C11-15] IDENTIFIER id3a\n[L2:C15-16] ,\n[L2:C16-17] +\n[L2:C17-18] *\n[L2:C18-19] ;\n[L2:C19-20] }\n[L2:C20-21] [\n[L2:C21-23] ||\n[L2:C23-25] ==\n[L2:C25-26] =\n[L2:C26-28] !=\n[L2:C28-29] (\n[L2:C29-30] )\n[L2:C30-32] &&\n[L2:C32-33] ]\n[L2:C33-34] <\n[L2:C34-35] >\n[L2:C35-37] <=\n[L2:C37-39] >=\n[L2:C39-40] =\n[L3:C1-2] IDENTIFIER a\n[L3:C2-3] [\n[L3:C3-5] INTLITERAL 24\n[L3:C5-6] ]\n[L3:C6-7] =\n[L3:C7-10] CHARLITERAL '7'\n[L3:C10-11] ;\n[L3:C12-13] IDENTIFIER n\n[L3:C13-15] !=\n[L3:C15-17] if\n[L3:C17-18] ;\n[L4:C1-6] BOOLEANLITERAL false\n[L4:C6-7] ,\n[L4:C7-8] -\n[L4:C8-10] if\n[L4:C10-11] ;\n[L4:C11-17] IDENTIFIER true32\n[L4:C17-18] ;\n[L5:C1-7] IDENTIFIER forpar\n"
                                            ),



  TestLabel "ws1" (parser "
// White-space characters.  This should produce several identifiers.
foo bar
baz	quux
meep  				  peem
whaahboom
doom


		
gloom    loom	weave
"
                                           ~=?
"[L2:C1-4] IDENTIFIER foo\n[L2:C5-8] IDENTIFIER bar\n[L3:C1-4] IDENTIFIER baz\n[L3:C5-9] IDENTIFIER quux\n[L4:C1-5] IDENTIFIER meep\n[L4:C13-17] IDENTIFIER peem\n[L5:C1-6] IDENTIFIER whaah\n[L5:C7-11] IDENTIFIER boom\n[L6:C1-5] IDENTIFIER doom\n[L10:C1-6] IDENTIFIER gloom\n[L10:C10-14] IDENTIFIER loom\n[L10:C15-20] IDENTIFIER weave\n"
                                            ),



