1. 

Raeez: Merged the scanners and parsers from week one, implemented
type classes for several common AST features, wrote tree rewrite code
for AST and Graphviz generation code, rewrote IR code 

Scott: Implemented monad for symbol table generation/lookup,
implemented semantic checks.

Justin: Set up testing framework, entered all tests, fixed bugs

2.

3.  We used essentially the same type structure that is generated by
the Parser as the current IR.  Semantic checks are done by walking the
IR and creating a symbol table as we go.  This is done with a monad
that keeps track of the symbol table, which is stored as a tree.  The
monad encapsulates most common operations on the symbol table: lookup
of identifiers, addition of identifiers, pushing new environments and
automatically removing them, error reporting, and environmental
awareness (for checking returns, breaks, continues).

4.  We continued to learn much about haskell.  Just implementing trees
with easy modification/access functions was something of a challenge
for me (scott).  The method I settled on was storing a copy of the
tree along with a context (a list of branch choices starting at the
root, going to the current node).  Manipulating the context is easy,
since it's just a list (moving up one level corresponds to taking the
init of the list, for example).  Modifying the data at any single node
requires modifications to all intermediate nodes leading up to the
root of the tree, since the whole structure is immutable, and the
context is just what is needed to do this efficiently.

I decided to use this for the symbol table since it is well suited for
performing the primary operations on environments, and it also
automatically gives the full symbol table at the end of the scan.

A considerable amount of time was spent rewriting our old type system
to support some of the new features we needed.  We are still 

